#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üôè Bot Prosperidad Divina - VERSI√ìN DEBUG COMPLETA
Ministerio Digital con IA - MODO PRUEBA con logging extensivo
CHANNEL_ID: UCgRg_G9C4-_AHBETHcc7cQQ
"""

import os
import json
import time
import traceback
from datetime import datetime, timedelta, timezone
from typing import List, Dict, Optional
import google.generativeai as genai
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

class ProsperidadDivinaBotDebug:
    def __init__(self):
        print("üëë INICIANDO BOT PROSPERIDAD DIVINA - MODO DEBUG COMPLETO")
        print("="*80)
        print("üß™ CONFIGURACI√ìN DEBUG:")
        print("   üìä M√°ximo 10 respuestas")
        print("   ‚è∞ Comentarios de √∫ltimas 48 horas")
        print("   üîç Logging extensivo para debug")
        print("   üìù Manejo de errores mejorado")
        print("="*80)
        
        # üîë Configuraci√≥n de APIs
        self.gemini_api_key = os.environ.get('GEMINI_API_KEY')
        self.youtube_credentials = os.environ.get('YOUTUBE_CREDENTIALS')
        
        print(f"üîê Verificando credenciales...")
        print(f"   GEMINI_API_KEY: {'‚úÖ PRESENTE' if self.gemini_api_key else '‚ùå FALTANTE'}")
        print(f"   YOUTUBE_CREDENTIALS: {'‚úÖ PRESENTE' if self.youtube_credentials else '‚ùå FALTANTE'}")
        
        if not all([self.gemini_api_key, self.youtube_credentials]):
            raise ValueError("‚ùå Faltan credenciales del ministerio en variables de entorno")
        
        # ü§ñ Configurar Gemini
        self.configurar_gemini()
        
        # üì∫ Configurar YouTube con OAuth
        self.youtube = self.configurar_youtube_oauth()
        
        # üÜî Channel ID confirmado
        self.channel_id = 'UCgRg_G9C4-_AHBETHcc7cQQ'  # Prosperidad Divina
        
        # üìä Estad√≠sticas de la prueba
        self.stats = {
            'respuestas_exitosas': 0,
            'comentarios_procesados': 0,
            'errores': 0,
            'peticiones_oracion': 0,
            'testimonios': 0,
            'abundancia_respuestas': 0,
            'saludos': 0,
            'general': 0
        }
        
        # ‚è∞ Configuraci√≥n para PRUEBA DEBUG
        self.hace_horas = 48  # 48 horas para encontrar comentarios
        self.max_respuestas = 10  # 10 comentarios para prueba
        
        # üìù Log detallado
        self.log_detallado = []
        
        print(f"‚úÖ Bot configurado para canal: {self.channel_id}")
        
    def configurar_gemini(self):
        """ü§ñ Configurar Gemini API"""
        try:
            print("ü§ñ Configurando Gemini...")
            genai.configure(api_key=self.gemini_api_key)
            self.model = genai.GenerativeModel('gemini-1.5-flash')
            print("‚úÖ Gemini configurado exitosamente")
        except Exception as e:
            print(f"‚ùå Error configurando Gemini: {e}")
            raise
        
    def configurar_youtube_oauth(self):
        """üîê Configurar YouTube API con credenciales OAuth"""
        try:
            print("üîê Configurando YouTube OAuth...")
            
            # Parsear credenciales JSON
            creds_data = json.loads(self.youtube_credentials)
            print(f"   üìä Credenciales parseadas: {len(creds_data)} campos")
            
            # Crear objeto de credenciales
            creds = Credentials.from_authorized_user_info(creds_data)
            print(f"   üîë Objeto de credenciales creado")
            
            # Crear servicio YouTube
            youtube = build('youtube', 'v3', credentials=creds)
            print("‚úÖ YouTube OAuth configurado exitosamente")
            
            return youtube
            
        except Exception as e:
            print(f"‚ùå Error configurando OAuth: {e}")
            print(f"   üìä Tipo de error: {type(e).__name__}")
            print(f"   üìÑ Detalle: {str(e)}")
            raise
    
    def verificar_canal(self):
        """üîç Verificar que podemos acceder al canal correcto"""
        try:
            print(f"\nüîç VERIFICANDO ACCESO AL CANAL: {self.channel_id}")
            
            # Verificar canal por ID
            response = self.youtube.channels().list(
                part='id,snippet,statistics',
                id=self.channel_id
            ).execute()
            
            print(f"üìä Respuesta API recibida: {len(response.get('items', []))} items")
            
            if response['items']:
                canal = response['items'][0]
                nombre = canal['snippet']['title']
                suscriptores = canal['statistics'].get('subscriberCount', 'N/A')
                videos = canal['statistics'].get('videoCount', 'N/A')
                
                print(f"‚úÖ Canal encontrado: {nombre}")
                print(f"üìä Suscriptores: {suscriptores}")
                print(f"üìπ Videos: {videos}")
                
                self.log_detallado.append({
                    'paso': 'verificacion_canal',
                    'resultado': 'exitoso',
                    'canal': nombre,
                    'suscriptores': suscriptores
                })
                
                return True
            else:
                print("‚ùå Canal no encontrado con ese ID")
                return False
                
        except HttpError as e:
            print(f"‚ùå Error HTTP verificando canal: {e}")
            print(f"   üìä C√≥digo de error: {e.resp.status}")
            return False
        except Exception as e:
            print(f"‚ùå Error general verificando canal: {e}")
            print(f"   üìä Tipo: {type(e).__name__}")
            return False
    
    def obtener_videos_recientes(self) -> List[Dict]:
        """üì∫ Obtener videos recientes del canal"""
        try:
            print(f"\nüì∫ OBTENIENDO VIDEOS RECIENTES DEL CANAL...")
            
            # Obtener uploads playlist
            print("   üîç Obteniendo playlist de uploads...")
            channel_response = self.youtube.channels().list(
                part='contentDetails',
                id=self.channel_id
            ).execute()
            
            if not channel_response.get('items'):
                print("‚ùå No se pudo obtener info del canal")
                return []
            
            uploads_playlist = channel_response['items'][0]['contentDetails']['relatedPlaylists']['uploads']
            print(f"   üìÅ Playlist uploads: {uploads_playlist}")
            
            # Obtener videos recientes
            print("   üìπ Obteniendo videos de la playlist...")
            playlist_response = self.youtube.playlistItems().list(
                part='snippet',
                playlistId=uploads_playlist,
                maxResults=8  # M√°s videos para encontrar comentarios
            ).execute()
            
            videos = []
            for i, item in enumerate(playlist_response.get('items', []), 1):
                video_info = {
                    'id': item['snippet']['resourceId']['videoId'],
                    'titulo': item['snippet']['title'],
                    'fecha': item['snippet']['publishedAt']
                }
                videos.append(video_info)
                print(f"üìπ Video {i}: {video_info['titulo'][:60]}...")
                print(f"   üÜî ID: {video_info['id']}")
            
            print(f"‚úÖ {len(videos)} videos encontrados para an√°lisis")
            
            self.log_detallado.append({
                'paso': 'obtencion_videos',
                'resultado': 'exitoso',
                'cantidad': len(videos),
                'videos': [v['titulo'][:50] for v in videos]
            })
            
            return videos
            
        except HttpError as e:
            print(f"‚ùå Error HTTP obteniendo videos: {e}")
            print(f"   üìä C√≥digo: {e.resp.status}")
            return []
        except Exception as e:
            print(f"‚ùå Error general obteniendo videos: {e}")
            print(f"   üìä Tipo: {type(e).__name__}")
            return []
    
    def obtener_comentarios_recientes(self, video_id: str, titulo_video: str) -> List[Dict]:
        """üí¨ Obtener comentarios recientes de un video"""
        try:
            print(f"\nüí¨ ANALIZANDO COMENTARIOS DE: {titulo_video[:50]}...")
            print(f"   üÜî Video ID: {video_id}")
            
            # Calcular fecha l√≠mite con timezone UTC
            fecha_limite = datetime.now(timezone.utc) - timedelta(hours=self.hace_horas)
            print(f"‚è∞ Buscando comentarios desde: {fecha_limite.strftime('%Y-%m-%d %H:%M UTC')} (√∫ltimas {self.hace_horas}h)")
            
            print("   üì° Llamando a YouTube API para comentarios...")
            response = self.youtube.commentThreads().list(
                part='snippet',
                videoId=video_id,
                order='time',
                maxResults=50,  # M√°s comentarios para tener mejor chance
                textFormat='plainText'
            ).execute()
            
            comentarios_totales = len(response.get('items', []))
            print(f"üìä {comentarios_totales} comentarios totales encontrados en este video")
            
            if comentarios_totales == 0:
                print("‚ö†Ô∏è  Este video no tiene comentarios")
                self.log_detallado.append({
                    'paso': f'comentarios_{video_id}',
                    'video': titulo_video[:50],
                    'comentarios_totales': 0,
                    'comentarios_recientes': 0,
                    'motivo': 'video_sin_comentarios'
                })
                return []
            
            comentarios_recientes = []
            
            for i, item in enumerate(response.get('items', []), 1):
                try:
                    comentario = item['snippet']['topLevelComment']['snippet']
                    fecha_comentario = datetime.fromisoformat(comentario['publishedAt'].replace('Z', '+00:00'))
                    
                    # Debug: mostrar info del comentario
                    autor = comentario['authorDisplayName']
                    texto = comentario['textDisplay'][:100]
                    fecha_str = fecha_comentario.strftime('%Y-%m-%d %H:%M')
                    
                    print(f"   üìù Comentario {i}: {autor} ({fecha_str})")
                    print(f"      üí≠ {texto}...")
                    
                    # Solo comentarios recientes
                    if fecha_comentario >= fecha_limite:
                        comentario_info = {
                            'id': item['snippet']['topLevelComment']['id'],
                            'texto': comentario['textDisplay'],
                            'autor': comentario['authorDisplayName'],
                            'fecha': comentario['publishedAt'],
                            'likes': comentario.get('likeCount', 0),
                            'video_titulo': titulo_video
                        }
                        comentarios_recientes.append(comentario_info)
                        print(f"      ‚úÖ INCLU√çDO (reciente)")
                    else:
                        print(f"      ‚è∏Ô∏è  Muy antiguo, omitido")
                        
                except Exception as e:
                    print(f"   ‚ùå Error procesando comentario {i}: {e}")
                    continue
            
            print(f"‚úÖ {len(comentarios_recientes)} comentarios recientes (√∫ltimas {self.hace_horas}h)")
            
            self.log_detallado.append({
                'paso': f'comentarios_{video_id}',
                'video': titulo_video[:50],
                'comentarios_totales': comentarios_totales,
                'comentarios_recientes': len(comentarios_recientes),
                'fecha_limite': fecha_limite.isoformat()
            })
            
            return comentarios_recientes
            
        except HttpError as e:
            print(f"‚ùå Error HTTP obteniendo comentarios del video: {e}")
            print(f"   üìä C√≥digo: {e.resp.status}")
            print(f"   üìÑ Detalle: {e}")
            
            self.log_detallado.append({
                'paso': f'error_comentarios_{video_id}',
                'video': titulo_video[:50],
                'error_tipo': 'HttpError',
                'error_codigo': e.resp.status,
                'error_detalle': str(e)
            })
            return []
            
        except Exception as e:
            print(f"‚ùå Error general obteniendo comentarios: {e}")
            print(f"   üìä Tipo: {type(e).__name__}")
            print(f"   üìÑ Traceback: {traceback.format_exc()}")
            
            self.log_detallado.append({
                'paso': f'error_comentarios_{video_id}',
                'video': titulo_video[:50],
                'error_tipo': type(e).__name__,
                'error_detalle': str(e)
            })
            return []
    
    def detectar_tipo_comentario(self, texto: str) -> str:
        """üîç Detectar el tipo de comentario para personalizar respuesta"""
        texto_lower = texto.lower()
        
        # Palabras clave para diferentes tipos
        peticion_oracion = ['ora', 'oraci√≥n', 'orar', 'ruega', 'ayuda', 'enfermo', 'problema', 'dificil', 'por favor', 'necesito']
        testimonio = ['testimonio', 'milagro', 'san√≥', 'bendici√≥n', 'gracias dios', 'funcion√≥', 'gloria', 'aleluya']
        duda_fe = ['duda', 'no creo', 'funciona', 'real', 'verdad', 'fake', 'falso']
        abundancia = ['dinero', 'trabajo', 'empleo', 'abundancia', 'prosperidad', 'econ√≥mico', 'plata', 'negocio']
        saludo = ['hola', 'bendiciones', 'saludos', 'buenas', 'am√©n', 'bendici√≥n']
        
        if any(palabra in texto_lower for palabra in peticion_oracion):
            self.stats['peticiones_oracion'] += 1
            return 'peticion_oracion'
        elif any(palabra in texto_lower for palabra in testimonio):
            self.stats['testimonios'] += 1
            return 'testimonio'
        elif any(palabra in texto_lower for palabra in duda_fe):
            return 'duda_fe'
        elif any(palabra in texto_lower for palabra in abundancia):
            self.stats['abundancia_respuestas'] += 1
            return 'abundancia'
        elif any(palabra in texto_lower for palabra in saludo):
            self.stats['saludos'] += 1
            return 'saludo'
        else:
            self.stats['general'] += 1
            return 'general'
    
    def generar_respuesta_ia(self, comentario: Dict, tipo: str) -> str:
        """ü§ñ Generar respuesta personalizada con Gemini"""
        try:
            print(f"ü§ñ Generando respuesta tipo '{tipo}' para: {comentario['texto'][:50]}...")
            
            # Prompts personalizados seg√∫n el tipo
            prompts = {
                'peticion_oracion': f"""
                Como asistente espiritual del canal "Prosperidad Divina", responde con amor y compasi√≥n a esta petici√≥n de oraci√≥n:
                
                "{comentario['texto']}"
                
                INSTRUCCIONES:
                - Respuesta c√°lida y emp√°tica (m√°ximo 35 palabras)
                - Confirma que orar√°s por la persona
                - Usa emojis apropiados: üôè, ‚ú®, üí´, üíñ
                - Menciona el amor de Dios
                - NO uses comillas ni asteriscos
                """,
                
                'testimonio': f"""
                Como asistente espiritual del canal "Prosperidad Divina", celebra este testimonio:
                
                "{comentario['texto']}"
                
                INSTRUCCIONES:
                - Respuesta de gozo y celebraci√≥n (m√°ximo 35 palabras)
                - Agradece por compartir
                - Usa emojis: üéâ, ‚ú®, üôå, üíñ, üåü
                - Glorifica a Dios por el milagro
                - NO uses comillas ni asteriscos
                """,
                
                'abundancia': f"""
                Como asistente espiritual del canal "Prosperidad Divina", responde sobre prosperidad:
                
                "{comentario['texto']}"
                
                INSTRUCCIONES:
                - Respuesta sobre abundancia divina (m√°ximo 35 palabras)
                - Menciona que Dios provee
                - Usa emojis: üí∞, ‚ú®, üôè, üåü, üí´
                - Habla de fe y confianza
                - NO uses comillas ni asteriscos
                """,
                
                'saludo': f"""
                Como asistente espiritual del canal "Prosperidad Divina", responde al saludo:
                
                "{comentario['texto']}"
                
                INSTRUCCIONES:
                - Saludo c√°lido y bendici√≥n (m√°ximo 25 palabras)
                - Agradece por ser parte de la comunidad
                - Usa emojis: ‚ú®, üôè, üíñ, üåÖ
                - Incluye bendiciones
                - NO uses comillas ni asteriscos
                """,
                
                'general': f"""
                Como asistente espiritual del canal "Prosperidad Divina", responde con amor:
                
                "{comentario['texto']}"
                
                INSTRUCCIONES:
                - Respuesta c√°lida y alentadora (m√°ximo 35 palabras)
                - Agradece la participaci√≥n
                - Usa emojis apropiados: ‚ú®, üôè, üíñ, üåÖ
                - Incluye bendiciones
                - NO uses comillas ni asteriscos
                """
            }
            
            prompt = prompts.get(tipo, prompts['general'])
            
            response = self.model.generate_content(prompt)
            respuesta = response.text.strip()
            
            # Limpiar respuesta de comillas y asteriscos
            respuesta = respuesta.replace('"', '').replace("'", '').replace('*', '')
            
            # Limitar longitud
            if len(respuesta) > 180:
                respuesta = respuesta[:177] + "..."
            
            print(f"‚úÖ Respuesta generada: {respuesta}")
            
            return respuesta
            
        except Exception as e:
            print(f"‚ùå Error generando respuesta IA: {e}")
            # Respuestas de respaldo seg√∫n tipo
            respuestas_respaldo = {
                'peticion_oracion': "Estar√© orando por ti üôè‚ú® Dios te ama y tiene cuidado de ti siempre üíñ",
                'testimonio': "¬°Gloria a Dios! üéâ Qu√© bendici√≥n leer tu testimonio ‚ú® Gracias por compartir üôè",
                'abundancia': "Dios es tu proveedor üí∞‚ú® Conf√≠a en su perfecta provisi√≥n para tu vida üôè",
                'saludo': "Bendiciones abundantes para ti ‚ú®üôè Gracias por ser parte de esta hermosa familia üíñ",
                'general': "Bendiciones infinitas para ti! üôè‚ú® Que el amor divino llene tu coraz√≥n siempre üíñ"
            }
            return respuestas_respaldo.get(tipo, respuestas_respaldo['general'])
    
    def responder_comentario(self, comentario_id: str, respuesta: str, comentario_original: Dict) -> bool:
        """üìù Responder a un comentario REALMENTE"""
        try:
            print(f"\nüìù ENVIANDO RESPUESTA...")
            print(f"   üë§ Autor: {comentario_original['autor']}")
            print(f"   üí¨ Comentario: {comentario_original['texto'][:80]}...")
            print(f"   üìù Respuesta: {respuesta}")
            
            # Preparar datos de la respuesta
            respuesta_data = {
                'snippet': {
                    'parentId': comentario_id,
                    'textOriginal': respuesta
                }
            }
            
            print("   üì° Enviando a YouTube API...")
            
            # Enviar respuesta usando la API
            response = self.youtube.comments().insert(
                part='snippet',
                body=respuesta_data
            ).execute()
            
            print(f"‚úÖ RESPUESTA ENVIADA EXITOSAMENTE")
            print(f"   üÜî Comment ID: {response.get('id', 'N/A')}")
            
            # Agregar a log detallado
            self.log_detallado.append({
                'paso': 'respuesta_enviada',
                'autor': comentario_original['autor'],
                'comentario_original': comentario_original['texto'][:100],
                'respuesta_enviada': respuesta,
                'comment_id': response.get('id'),
                'timestamp': datetime.now().isoformat()
            })
            
            return True
            
        except HttpError as e:
            error_details = e.content.decode('utf-8') if hasattr(e, 'content') else str(e)
            print(f"‚ùå ERROR HTTP ENVIANDO RESPUESTA: {error_details}")
            print(f"   üìä C√≥digo: {e.resp.status}")
            self.stats['errores'] += 1
            
            # Agregar error a log
            self.log_detallado.append({
                'paso': 'error_respuesta',
                'autor': comentario_original['autor'],
                'error_tipo': 'HttpError',
                'error_codigo': e.resp.status,
                'error': error_details,
                'timestamp': datetime.now().isoformat()
            })
            
            return False
        except Exception as e:
            print(f"‚ùå ERROR GENERAL ENVIANDO RESPUESTA: {e}")
            print(f"   üìä Tipo: {type(e).__name__}")
            print(f"   üìÑ Traceback: {traceback.format_exc()}")
            self.stats['errores'] += 1
            return False
    
    def procesar_comentarios(self):
        """üöÄ Proceso principal: obtener y responder comentarios - MODO DEBUG"""
        print(f"\nüîÑ INICIANDO PROCESAMIENTO EN MODO DEBUG")
        print(f"‚è∞ Buscando comentarios de las √∫ltimas {self.hace_horas} horas")
        print(f"üéØ M√ÅXIMO {self.max_respuestas} respuestas (MODO PRUEBA)")
        print(f"üì∫ Canal: {self.channel_id}")
        
        # Verificar acceso al canal
        print("\n" + "="*60)
        if not self.verificar_canal():
            print("‚ùå No se pudo verificar acceso al canal")
            return
        
        # Obtener videos recientes
        print("\n" + "="*60)
        videos = self.obtener_videos_recientes()
        
        if not videos:
            print("‚ùå No se encontraron videos para procesar")
            return
        
        total_respuestas = 0
        
        # Procesar cada video
        for i, video in enumerate(videos, 1):
            if total_respuestas >= self.max_respuestas:
                print(f"‚úÖ L√çMITE DE PRUEBA ALCANZADO: {self.max_respuestas} respuestas")
                break
                
            print(f"\n" + "="*60)
            print(f"üìπ PROCESANDO VIDEO {i}/{len(videos)}")
            
            comentarios = self.obtener_comentarios_recientes(video['id'], video['titulo'])
            
            if not comentarios:
                print(f"‚ö†Ô∏è  No se encontraron comentarios recientes en este video")
                continue
            
            for j, comentario in enumerate(comentarios, 1):
                if total_respuestas >= self.max_respuestas:
                    print(f"‚úÖ L√çMITE ALCANZADO: {self.max_respuestas} respuestas")
                    break
                
                self.stats['comentarios_procesados'] += 1
                
                print(f"\n" + "-"*80)
                print(f"üìù PROCESANDO COMENTARIO #{total_respuestas + 1} (Video {i}, Comentario {j})")
                print(f"üë§ Autor: {comentario['autor']}")
                print(f"üìπ Video: {comentario['video_titulo'][:50]}...")
                print(f"üí¨ Comentario: {comentario['texto']}")
                
                # Detectar tipo de comentario
                tipo = self.detectar_tipo_comentario(comentario['texto'])
                print(f"üîç Tipo detectado: {tipo.upper()}")
                
                # Generar respuesta personalizada
                respuesta = self.generar_respuesta_ia(comentario, tipo)
                
                # Enviar respuesta REAL
                if self.responder_comentario(comentario['id'], respuesta, comentario):
                    self.stats['respuestas_exitosas'] += 1
                    total_respuestas += 1
                    
                    print(f"‚úÖ RESPUESTA #{total_respuestas} ENVIADA EXITOSAMENTE")
                    
                    # Pausa entre respuestas para evitar rate limiting
                    if total_respuestas < self.max_respuestas:
                        print(f"‚è∏Ô∏è  Pausa de 3 segundos antes del siguiente comentario...")
                        time.sleep(3)
                else:
                    print("‚ùå NO SE PUDO ENVIAR RESPUESTA")
                    
                print("-"*80)
        
        print(f"\nüéâ PROCESAMIENTO DEBUG COMPLETADO")
        print(f"üìä {total_respuestas} respuestas enviadas exitosamente")
    
    def generar_reporte_debug(self):
        """üìä Generar reporte detallado del debug"""
        ahora = datetime.now()
        
        reporte = {
            'timestamp': ahora.isoformat(),
            'fecha_legible': ahora.strftime('%d de %B %Y - %H:%M'),
            'channel_id': self.channel_id,
            'modo': 'DEBUG_10_COMENTARIOS_48H',
            'stats': self.stats,
            'config': {
                'horas_buscadas': self.hace_horas,
                'max_respuestas': self.max_respuestas,
                'tipo': 'RESPUESTAS_REALES_OAUTH_DEBUG'
            },
            'log_detallado': self.log_detallado
        }
        
        # Guardar reporte JSON
        with open('reporte_debug_ministerio.json', 'w', encoding='utf-8') as f:
            json.dump(reporte, f, indent=2, ensure_ascii=False)
        
        # Reporte legible
        print(f"\nüìã REPORTE DETALLADO DE DEBUG")
        print(f"üïê {reporte['fecha_legible']}")
        print(f"üì∫ Canal: {self.channel_id}")
        print(f"üß™ Modo: DEBUG (m√°ximo {self.max_respuestas} respuestas, {self.hace_horas}h)")
        print(f"\nüìä ESTAD√çSTICAS FINALES:")
        print(f"   üí¨ Comentarios procesados: {self.stats['comentarios_procesados']}")
        print(f"   ‚úÖ Respuestas enviadas: {self.stats['respuestas_exitosas']}")
        print(f"   üôè Peticiones de oraci√≥n: {self.stats['peticiones_oracion']}")
        print(f"   üéâ Testimonios: {self.stats['testimonios']}")
        print(f"   üí∞ Abundancia: {self.stats['abundancia_respuestas']}")
        print(f"   üëã Saludos: {self.stats['saludos']}")
        print(f"   üìù General: {self.stats['general']}")
        print(f"   ‚ùå Errores: {self.stats['errores']}")
        
        print(f"\nüìÅ Reporte completo guardado en: reporte_debug_ministerio.json")
        print(f"üîç Revisa el log_detallado para ver cada paso ejecutado")
        
        return reporte

def main():
    """üöÄ Funci√≥n principal del bot - MODO DEBUG"""
    try:
        print("üôè BOT PROSPERIDAD DIVINA - MODO DEBUG COMPLETO")
        print("="*80)
        print("üß™ CONFIGURACI√ìN DEBUG ESPECIAL:")
        print("   üìä M√°ximo 10 respuestas")
        print("   ‚è∞ B√∫squeda en √∫ltimas 48 horas")
        print("   üîç Logging extensivo para cada paso")
        print("   üìù Manejo de errores detallado")
        print("   üî• Respuestas REALES con OAuth")
        print("="*80)
        
        # Inicializar bot
        bot = ProsperidadDivinaBotDebug()
        
        # Procesar comentarios
        bot.procesar_comentarios()
        
        # Generar reporte
        bot.generar_reporte_debug()
        
        print(f"\n‚ú® DEBUG COMPLETADO CON √âXITO")
        print(f"üîç Revisa el reporte detallado para analizar todos los pasos")
        print(f"üëë Prosperidad Divina - Ministerio Digital Debug")
        
    except Exception as e:
        print(f"\n‚ùå ERROR CR√çTICO EN DEBUG: {e}")
        print(f"üìä Tipo: {type(e).__name__}")
        print(f"üìÑ Traceback completo:")
        print(traceback.format_exc())
        
        # Guardar error para an√°lisis
        error_info = {
            'timestamp': datetime.now().isoformat(),
            'error': str(e),
            'tipo': type(e).__name__,
            'traceback': traceback.format_exc(),
            'modo': 'DEBUG'
        }
        
        with open('error_debug.json', 'w', encoding='utf-8') as f:
            json.dump(error_info, f, indent=2, ensure_ascii=False)

if __name__ == "__main__":
    main()
